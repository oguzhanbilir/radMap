<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>Arduino Devre Kodu Rehberi | RadMap</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        .guide-body h4 { margin-top: 1rem; }
        .guide-body .code-caption { font-size: 0.88rem; color: var(--accent); margin-bottom: 0.35rem; }
        .guide-body .step-num { display: inline-block; width: 1.5rem; color: var(--accent); font-weight: 700; }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="index.html" class="logo">RadMap</a>
            <ul>
                <li><a href="index.html">Ana Sayfa</a></li>
                <li><a href="malzemeler.html">Malzemeler</a></li>
                <li><a href="proje.html">Proje Süreci</a></li>
                <li><a href="olcum-sonuclari.html">Ölçüm Sonuçları</a></li>
                <li><a href="takim.html">Takım</a></li>
                <li><a href="portfolyo.html">Proje Çıktıları</a></li>
                <li><a href="rehberler.html">Kod Rehberleri</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="hero">
            <h1>Arduino Devre Kodu Rehberi</h1>
            <p class="tagline">Fonksiyon fonksiyon, blok blok açıklama — öğrenciler için kapsamlı kod rehberi</p>
        </section>

        <section>
            <div class="guide-grid">
                <div class="guide-card guide-card-wide">
                    <h3>Programın genel akışı</h3>
                    <p class="guide-desc">Bu rehber <strong>RadMap_Tam.ino</strong> dosyasını açıklar. Öğrenciler aşağıdaki bölümleri sırayla okuyarak her fonksiyonun ve her kod bloğunun ne işe yaradığını çalışabilir. Veriler <strong>LOG.csv</strong> dosyasına <strong>Tarih, Saat, Enlem, Boylam, CPM, uSv/h, Uydu</strong> sütunlarıyla yazılır.</p>
                    <ul>
                        <li><strong>setup()</strong> → Bir kez çalışır: pinler, kesme, OLED, SD kart hazırlanır.</li>
                        <li><strong>loop()</strong> → Sürekli tekrarlanır: GPS okunur; her 1 saniyede CPM/µSv/h hesaplanır, LOG.csv’ye yazılır, OLED güncellenir.</li>
                    </ul>

                    <details class="guide-accordion" open>
                        <summary><strong>Hangi fonksiyon ne işe yarıyor? (Özet tablo)</strong></summary>
                        <div class="guide-body">
                            <table style="width:100%; border-collapse:collapse; font-size:0.9rem;">
                                <tr style="background:rgba(0,212,170,0.15);"><th style="padding:0.4rem; text-align:left;">Fonksiyon</th><th style="padding:0.4rem; text-align:left;">Ne işe yarar?</th></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledCmd(c)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">OLED ekrana tek bir komut gönderir (I2C).</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledInit()</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Ekranı açar ve başlatır (A4=SDA, A5=SCL).</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledClearPage(page)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">OLED’in tek bir sayfasını (8 piksel yükseklik) siler.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledClear()</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Tüm ekranı siler.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>charToIdx(c)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Karakteri font indeksine çevirir (5x7 font için).</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledDrawChar(x, page, c)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Belirtilen konuma tek karakter çizer.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledPrint(x, page, s)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Metin (string) yazar.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>oledPrintNum(...)</code> / <code>oledPrintFloat(...)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Sayıyı ekrana yazar.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>geigerISR()</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Kesme fonksiyonu: Geiger her vuruşta D2 yükselince <code>pulseCount</code> artar.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>formatTarihSaat(bufTarih, bufSaat)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">GPS’ten tarih/saat alır; <strong>YYYY-MM-DD</strong> ve <strong>HH:MM:SS</strong> formatında doldurur. Uydu yoksa 2000-01-01, 00:00:00.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>writeToSD(cpm, usvh, lat, lng, uyduSayisi)</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">LOG.csv dosyasına bir satır yazar (başlık + Tarih, Saat, Enlem, Boylam, CPM, uSv/h, Uydu). <code>true</code>/<code>false</code> döner.</td></tr>
                                <tr><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);"><code>setup()</code></td><td style="padding:0.35rem; border-bottom:1px solid rgba(0,212,170,0.2);">Bir kez: Serial, GPS seri, Geiger kesme, OLED, SD kart başlatılır.</td></tr>
                                <tr><td style="padding:0.35rem;"><code>loop()</code></td><td style="padding:0.35rem;">Sürekli: GPS byte’ları okunur; her 1 saniyede CPM/µSv/h hesaplanır, GPS değerleri alınır, SD’ye yazılır, OLED ve Serial güncellenir. <code>gpsByteCount</code> ile GPS’ten veri gelip gelmediği kontrol edilir.</td></tr>
                            </table>
                            <p style="margin-top:0.75rem;"><strong>Önemli global değişkenler:</strong> <code>pulseCount</code> = kesmede artan Geiger vuruş sayısı; <code>counts[60]</code> = son 60 saniyenin her saniyedeki vuruşu (CPM hesabı); <code>bufferIndex</code>, <code>totalCountsInWindow</code>, <code>uptimeSeconds</code> = kayan pencere için; <code>sdOk</code> = SD kart başarıyla açıldı mı; <code>gpsByteCount</code> = son saniyede GPS’ten gelen byte sayısı (debug).</p>
                        </div>
                    </details>

                    <!-- ========== 1. KÜTÜPHANELER VE PIN TANIMLARI ========== -->
                    <details class="guide-accordion" open>
                        <summary>1. Kütüphaneler ve pin tanımları (satır satır)</summary>
                        <div class="guide-body">
                            <p class="code-caption">Ne işe yarar?</p>
                            <p>Bu satırlar dış kütüphaneleri programa dahil eder ve hangi Arduino pininin ne için kullanıldığını sabitler. Böylece kodda 2, 3, 4 yazmak yerine GEIGER_PIN, GPS_RX_PIN gibi anlamlı isimler kullanırız.</p>
                            <pre class="code-block"><code>#include &lt;Wire.h&gt;           // I2C haberleşme — OLED ekran A4 (SDA), A5 (SCL) üzerinden
#include &lt;SPI.h&gt;            // SD kart SPI ile konuşur (D10 = CS, D11 MOSI, D12 MISO, D13 SCK)
#include &lt;SoftwareSerial.h&gt; // GPS için ikinci bir seri port (USB Serial’i PC’ye ayırıyoruz)
#include &lt;TinyGPS++.h&gt;      // NMEA cümlelerini işleyip enlem, boylam, rakım verir
#include &lt;SD.h&gt;             // Micro SD karta dosya yazmak için

#define GEIGER_PIN 2   // Geiger-Müller TTL çıkışı bu pinde — her vuruşta sinyal gelir
#define GPS_RX_PIN 3   // Arduino’nun RX’i — GPS modülünün TX’ine bağlanır (veri GPS’ten gelir)
#define GPS_TX_PIN 4   // Arduino’nun TX’i — GPS modülünün RX’ine bağlanır (isteğe bağlı)
#define SD_CS_PIN  10  // SD kart “Chip Select” — SPI’da hangi cihazın seçili olduğu</code></pre>
                            <p><strong>Özet:</strong> Wire = OLED, SPI = SD, SoftwareSerial = GPS, TinyGPS++ = konum çözümleme, SD = dosya. Pinler: D2 Geiger, D3–D4 GPS, D10 SD.</p>
                        </div>
                    </details>

                    <!-- ========== 2. OLED FONKSİYONLARI ========== -->
                    <details class="guide-accordion" open>
                        <summary>2. OLED ekran fonksiyonları (fonksiyon fonksiyon)</summary>
                        <div class="guide-body">
                            <h4>2.1 oledCmd(uint8_t c) — Tek komut gönderir</h4>
                            <p><strong>Ne yapar?</strong> OLED ekran I2C adresi 0x3C’tir. Ekrana “komut” göndermek için önce 0x00 (komut modu), sonra komut baytı yazılır. Bu fonksiyon tam olarak bunu yapar.</p>
                            <p><strong>Parametre:</strong> <code>c</code> — SSD1306 ekran komutu (örn. 0xAE = display off).</p>
                            <pre class="code-block"><code>void oledCmd(uint8_t c) {
  Wire.beginTransmission(OLED_ADDR);  // I2C adresi 0x3C’e başla
  Wire.write(0x00);                    // Sonraki byte komut (0x40 olsaydı veri olurdu)
  Wire.write(c);                       // Komutu gönder
  Wire.endTransmission();              // I2C iletimini bitir
}</code></pre>

                            <h4>2.2 oledInit() — Ekranı başlatır</h4>
                            <p><strong>Ne yapar?</strong> I2C’i açar, ekrana sırayla başlatma komutları gönderir (frekans, çoklayıcı, offset, açma vb.). Bu komutlar SSD1306 veri sayfasından alınır; ekran açıldıktan sonra pikselleri yazabiliriz.</p>
                            <pre class="code-block"><code>void oledInit() {
  Wire.begin();      // I2C iletişimini başlat (A4=SDA, A5=SCL)
  delay(100);        // Ekranın hazır olmasını bekle
  oledCmd(0xAE);     // Display off
  oledCmd(0xD5); oledCmd(0x80);  // Clock ayarı
  oledCmd(0xA8); oledCmd(0x3F);  // Çoklayıcı (64 satır)
  oledCmd(0xD3); oledCmd(0x00);  // Display offset
  oledCmd(0x40);     // Başlangıç satırı
  oledCmd(0x8D); oledCmd(0x14);  // Charge pump
  oledCmd(0x20); oledCmd(0x02);  // Yatay adresleme
  oledCmd(0xA1); oledCmd(0xC8);  // Segment remap, COM scan
  oledCmd(0xDA); oledCmd(0x12);  // COM pins
  oledCmd(0x81); oledCmd(0x7F);  // Kontrast
  oledCmd(0xD9); oledCmd(0xF1);  // Precharge
  oledCmd(0xDB); oledCmd(0x40);  // VCOMH
  oledCmd(0xA4); oledCmd(0xA6);  // Tüm pikseller normal, normal renk
  oledCmd(0xAF);     // Display on
  delay(100);
}</code></pre>

                            <h4>2.3 oledClearPage(uint8_t page) — Tek sayfayı siler</h4>
                            <p><strong>Ne yapar?</strong> OLED 128x64 piksel; dikeyde 8 “sayfa” (her sayfa 8 piksel yükseklik). Bu fonksiyon verilen sayfa numarasındaki tüm sütunları 0 yapar (siyah).</p>
                            <p><strong>Blok açıklaması:</strong> Önce sayfa adresi (0xB0 + page), sonra sütun adresi ayarlanır; 16’şar bayt veri (0) gönderilir. WIRE_CHUNK=16 çünkü I2C’te çok uzun veri tek seferde gönderilmez.</p>
                            <pre class="code-block"><code>void oledClearPage(uint8_t page) {
  for (uint8_t col = 0; col &lt; OLED_W; col += WIRE_CHUNK) {
    oledCmd(0xB0 + page);              // Sayfa seç (0..7)
    oledCmd(0x00 | (col & 0x0F));      // Sütun düşük 4 bit
    oledCmd(0x10 | (col &gt;&gt; 4));        // Sütun yüksek bitler
    Wire.beginTransmission(OLED_ADDR);
    Wire.write(0x40);                  // 0x40 = veri modu (komut değil)
    uint8_t n = (col + WIRE_CHUNK &lt;= OLED_W) ? WIRE_CHUNK : (OLED_W - col);
    for (uint8_t i = 0; i &lt; n; i++) Wire.write(0);  // Sıfırları yaz
    Wire.endTransmission();
  }
}</code></pre>

                            <h4>2.4 oledClear() — Tüm ekranı siler</h4>
                            <p><strong>Ne yapar?</strong> 8 sayfanın hepsini tek tek siler; ekran tamamen siyah olur.</p>
                            <pre class="code-block"><code>void oledClear() {
  for (uint8_t p = 0; p &lt; OLED_PAGES; p++) oledClearPage(p);
}</code></pre>

                            <h4>2.5 charToIdx(char c) — Harf → font indeksi</h4>
                            <p><strong>Ne yapar?</strong> Ekranda yazı göstermek için 5x7 piksel font kullanıyoruz. Her karakter (boşluk, rakam, harf, nokta vb.) font dizisinde bir indekse karşılık gelir. Bu fonksiyon verilen karakteri o indekse çevirir.</p>
                            <pre class="code-block"><code>uint8_t charToIdx(char c) {
  if (c == ' ') return 0;
  if (c &gt;= '0' &amp;&amp; c &lt;= '9') return 1 + (c - '0');   // 0→1, 1→2, ... 9→10
  if (c == '.') return 11;
  if (c == ':') return 12;
  if (c == '-') return 13;
  // C, P, M, u, S, v, h, D, R, O, N, E, L, A, B, t, i, y, r, a, l, !, U, Y, I, /
  // ... (kodda hepsi var)
  return 0;
}</code></pre>

                            <h4>2.6 oledDrawChar(x, page, c) — Tek karakter çizer</h4>
                            <p><strong>Ne yapar?</strong> (x, page) konumuna tek bir karakter çizer. Önce o konuma cursor gider (sayfa + sütun komutları), sonra font5x7 dizisinden 5 sütunluk veri 0x40 (veri) ile yazılır.</p>
                            <pre class="code-block"><code>void oledDrawChar(uint8_t x, uint8_t page, char c) {
  uint8_t idx = charToIdx(c);
  if (idx &gt; 39) idx = 0;
  oledCmd(0xB0 + page);      // Sayfa
  oledCmd(0x00 | (x & 0x0F));
  oledCmd(0x10 | (x &gt;&gt; 4));
  Wire.beginTransmission(OLED_ADDR);
  Wire.write(0x40);
  for (uint8_t col = 0; col &lt; 5; col++)
    Wire.write(pgm_read_byte(&amp;font5x7[idx][col]));  // PROGMEM’den oku
  Wire.endTransmission();
}</code></pre>

                            <h4>2.7 oledPrint(x, page, s) — Metin yazar</h4>
                            <p><strong>Ne yapar?</strong> Verilen string’i (s) soldan itibaren (x, page) konumuna yazar. Her karakter 6 birim sağa kayar; satır taşarsa bir sonraki sayfaya geçer.</p>
                            <pre class="code-block"><code>void oledPrint(uint8_t x, uint8_t page, const char* s) {
  while (*s) {
    oledDrawChar(x, page, *s++);
    x += 6;
    if (x &gt;= 124) { x = 0; page++; }
  }
}</code></pre>

                            <h4>2.8 oledPrintNum / oledPrintFloat — Sayı yazar</h4>
                            <p><strong>Ne yapar?</strong> Tam sayıyı veya ondalıklı sayıyı stringe çevirip oledPrint ile yazar. <code>itoa</code> tam sayı, <code>dtostrf</code> float için kullanılır.</p>
                            <pre class="code-block"><code>void oledPrintNum(uint8_t x, uint8_t page, uint32_t n) {
  char buf[12];
  itoa((int)n, buf, 10);   // 10’luk tabanda string yap
  oledPrint(x, page, buf);
}

void oledPrintFloat(uint8_t x, uint8_t page, float f, uint8_t decimals) {
  char buf[16];
  dtostrf(f, 0, decimals, buf);  // ondalık basamak sayısı = decimals
  oledPrint(x, page, buf);
}</code></pre>
                        </div>
                    </details>

                    <!-- ========== 3. GEIGER KESME VE DEĞİŞKENLER ========== -->
                    <details class="guide-accordion" open>
                        <summary>3. Geiger sayacı: değişkenler ve kesme (geigerISR)</summary>
                        <div class="guide-body">
                            <p class="code-caption">Neden kesme (interrupt) kullanıyoruz?</p>
                            <p>Geiger tüpü radyasyonu algıladığında TTL çıkışta çok kısa bir darbe (birkaç mikrosaniye) üretir. Bu darbeleri <code>loop()</code> içinde <code>digitalRead</code> ile okumaya çalışırsak birçoğunu kaçırabiliriz. Kesme kullanınca her yükselen kenar (RISING) geldiğinde <code>geigerISR</code> otomatik çağrılır ve sayacı artırırız.</p>
                            <h4>3.1 Global değişkenler</h4>
                            <pre class="code-block"><code>uint8_t counts[60];           // Son 60 saniyenin her birindeki vuruş sayısı (dairesel tampon)
uint8_t bufferIndex = 0;       // Tamponda “şu an yazılan yer” indeksi (0..59)
uint32_t totalCountsInWindow = 0;  // Son 60 saniyedeki toplam vuruş (CPM hesabı için)
uint32_t uptimeSeconds = 0;   // Açılıştan beri kaç saniye geçti
uint32_t lastLogTime = 0;      // Son 1 saniyelik işlemin yapıldığı zaman (millis())

volatile uint32_t pulseCount = 0;        // Kesme içinde artırılan vuruş sayacı (1 saniyede kaç vuruş)
volatile uint32_t lastInterruptTime = 0; // Son kesme zamanı — gürültü filtrelemek için</code></pre>
                            <p><strong>volatile ne demek?</strong> Kesme fonksiyonu ana programdan bağımsız çalıştığı için derleyici bu değişkeni “optimize” edip silmesin diye <code>volatile</code> yazarız.</p>
                            <h4>3.2 geigerISR() — Kesme fonksiyonu (satır satır)</h4>
                            <pre class="code-block"><code>void geigerISR() {
  uint32_t now = micros();                          // Şu anki zaman (mikrosaniye)
  if (now - lastInterruptTime &gt; 200) {              // Son darbeden 200 µs geçmiş mi?
    pulseCount++;                                    // Evet → gerçek vuruş say, 1 artır
    lastInterruptTime = now;                         // Bu darbenin zamanını kaydet
  }
  // 200 µs’den kısa aralıkları sayma — elektrik gürültüsü çift sayımı engeller
}</code></pre>
                            <p><strong>setup() içinde bağlama:</strong></p>
                            <pre class="code-block"><code>pinMode(GEIGER_PIN, INPUT);  // D2’yi giriş yap
attachInterrupt(digitalPinToInterrupt(GEIGER_PIN), geigerISR, RISING);
// D2 pininde yükselen kenar (LOW→HIGH) olduğunda geigerISR çağrılır</code></pre>
                        </div>
                    </details>

                    <!-- ========== 4. CPM HESAPLAMA (60 SN PENCERE) ========== -->
                    <details class="guide-accordion" open>
                        <summary>4. CPM ve µSv/h hesaplama (blok blok)</summary>
                        <div class="guide-body">
                            <p><strong>CPM</strong> = Counts Per Minute (dakikadaki vuruş sayısı). Radyasyon şiddeti CPM ile orantılıdır. <strong>µSv/h</strong> = mikrosievert/saat; doz hızı birimi. Formül: <code>µSv/h = CPM × 0.00812</code> (sensör kalibrasyon katsayısı).</p>
                            <p><strong>Neden 60 saniyelik pencere?</strong> Tek saniyedeki vuruş sayısı çok dalgalı olabilir. Son 60 saniyeyi kullanarak “kaydırmalı ortalama” alıyoruz; değer daha kararlı olur.</p>
                            <h4>4.1 Her saniye yapılan işlem (loop içinde)</h4>
                            <p class="code-caption">Adım 1: Kesmeyi kapat, sayacı oku ve sıfırla</p>
                            <pre class="code-block"><code>noInterrupts();                    // Kesmeleri geçici kapat (sayıyı okurken değişmesin)
uint8_t currentSecCounts = pulseCount;  // Bu saniyedeki vuruş sayısını kopyala
pulseCount = 0;                         // Sıfırla — önümüzdeki saniye için yeniden sayılacak
interrupts();                           // Kesmeleri tekrar aç</code></pre>
                            <p class="code-caption">Adım 2: Dairesel tamponu güncelle (60 elemanlı)</p>
                            <pre class="code-block"><code>totalCountsInWindow -= counts[bufferIndex];  // Eski değeri pencereden çıkar
counts[bufferIndex] = currentSecCounts;       // Bu saniyenin sayısını yaz
totalCountsInWindow += currentSecCounts;      // Toplama ekle
bufferIndex = (bufferIndex + 1) % 60;         // İndeksi ilerlet (59’dan sonra 0)</code></pre>
                            <p class="code-caption">Adım 3: CPM hesapla</p>
                            <pre class="code-block"><code>uint32_t cpm = 0;
if (uptimeSeconds &lt; 60) {
  if (uptimeSeconds &gt; 0)
    cpm = (totalCountsInWindow * 60) / uptimeSeconds;  // Henüz 60 sn dolmadıysa oranla
} else {
  cpm = totalCountsInWindow;   // Tam 60 saniye doldu → toplam vuruş = CPM
}</code></pre>
                            <p class="code-caption">Adım 4: µSv/h’a çevir</p>
                            <pre class="code-block"><code>float usvh = cpm * 0.00812;   // Kalibrasyon katsayısı (sensör veri sayfasından)</code></pre>
                        </div>
                    </details>

                    <!-- ========== 5. GPS, formatTarihSaat VE writeToSD (LOG.csv) ========== -->
                    <details class="guide-accordion" open>
                        <summary>5. GPS okuma, Tarih/Saat ve SD karta yazma (LOG.csv)</summary>
                        <div class="guide-body">
                            <h4>5.1 GPS nesneleri</h4>
                            <p><strong>Ne işe yarar?</strong> <code>TinyGPSPlus gps</code> NMEA cümlelerini işleyip enlem, boylam, tarih, saat ve uydu sayısı verir. <code>SoftwareSerial gpsSerial(GPS_RX_PIN, GPS_TX_PIN)</code> ile D3 (RX) ve D4 (TX) üzerinden 9600 baud ile konuşuruz. <strong>GPS modülünün TX pini Arduino D3’e (RX) bağlı olmalı.</strong></p>
                            <pre class="code-block"><code>TinyGPSPlus gps;   // .location.lat(), .location.lng(), .date, .time, .satellites
SoftwareSerial gpsSerial(GPS_RX_PIN, GPS_TX_PIN);  // D3=RX, D4=TX, 9600 baud</code></pre>
                            <h4>5.2 GPS verisini okumak (loop içinde sürekli)</h4>
                            <p>GPS modülü NMEA cümleleri ($GPGGA, $GPRMC vb.) yollar. Her gelen byte <code>gps.encode()</code> ile kütüphaneye verilir; enlem, boylam, tarih, saat, uydu sayısı güncellenir. <strong>gpsByteCount</strong> her saniye kaç byte geldiğini sayar; Serial’da <code>GPS_byt: 0</code> görürsen kablo/pin (GPS TX→D3) kontrol et.</p>
                            <pre class="code-block"><code>while (gpsSerial.available()) {
  gps.encode(gpsSerial.read());
  gpsByteCount++;   // Debug: saniyede kaç byte geldiği
}</code></pre>
                            <h4>5.3 Enlem, boylam, uydu sayısı alma</h4>
                            <p>Konum ve uydu sayısı <code>isValid()</code> ile kontrol edilir; uydu kilidi yoksa 0 kullanılır.</p>
                            <pre class="code-block"><code>float lat = gps.location.isValid() ? (float)gps.location.lat() : 0.0f;   // Enlem
float lng = gps.location.isValid() ? (float)gps.location.lng() : 0.0f;   // Boylam
uint8_t uyduSayisi = gps.satellites.isValid() ? (uint8_t)gps.satellites.value() : 0;  // Uydu</code></pre>
                            <h4>5.4 formatTarihSaat(bufTarih, bufSaat) — Tarih ve saati metne çevirir</h4>
                            <p><strong>Ne yapar?</strong> GPS’ten tarih ve saati alır; <strong>YYYY-MM-DD</strong> ve <strong>HH:MM:SS</strong> formatında iki karakter dizisine yazar. Uydu kilidi yoksa 2000-01-01 ve 00:00:00 kullanılır. LOG.csv’deki Tarih ve Saat sütunları bu fonksiyonla doldurulur.</p>
                            <pre class="code-block"><code>void formatTarihSaat(char* bufTarih, char* bufSaat) {
  int y = 2000, m = 1, d = 1, h = 0, mi = 0, s = 0;
  if (gps.date.isValid()) { y = gps.date.year(); m = gps.date.month(); d = gps.date.day(); }
  if (gps.time.isValid()) { h = gps.time.hour(); mi = gps.time.minute(); s = gps.time.second(); }
  sprintf(bufTarih, "%04d-%02d-%02d", y, m, d);   // 2026-02-06
  sprintf(bufSaat,  "%02d:%02d:%02d", h, mi, s);   // 11:15:38
}</code></pre>
                            <h4>5.5 writeToSD() — LOG.csv’ye bir satır yazar</h4>
                            <p><strong>Ne yapar?</strong> <strong>LOG.csv</strong> dosyasını açar (yoksa oluşturur). Dosya boşsa önce başlık satırını yazar: <code>Tarih,Saat,Enlem,Boylam,CPM,uSv/h,Uydu</code>. Sonra her çağrıda bir veri satırı ekler: Tarih, Saat, Enlem, Boylam, CPM, uSv/h, Uydu. Yazım başarılıysa <code>true</code>, değilse <code>false</code> döner.</p>
                            <pre class="code-block"><code>bool writeToSD(uint32_t cpm, float usvh, float lat, float lng, uint8_t uyduSayisi) {
  File f = SD.open("LOG.csv", FILE_WRITE);
  if (!f) return false;
  if (f.size() == 0)   // İlk satır: başlık
    f.println(F("Tarih,Saat,Enlem,Boylam,CPM,uSv/h,Uydu"));
  char bufTarih[11], bufSaat[9];
  formatTarihSaat(bufTarih, bufSaat);
  f.print(bufTarih);  f.print(",");
  f.print(bufSaat);   f.print(",");
  f.print(lat, 6);   f.print(",");
  f.print(lng, 6);   f.print(",");
  f.print(cpm);      f.print(",");
  f.print(usvh, 3);  f.print(",");
  f.println(uyduSayisi);
  f.close();
  return true;
}</code></pre>
                        </div>
                    </details>

                    <!-- ========== 6. setup() BLOK BLOK ========== -->
                    <details class="guide-accordion" open>
                        <summary>6. setup() — Açılışta bir kez (blok blok)</summary>
                        <div class="guide-body">
                            <p><strong>setup()</strong> Arduino açıldığında veya resetlendiğinde yalnızca bir kez çalışır. Amaç: seri portları, pinleri, kesmeyi, OLED’i ve SD kartı hazırlamak.</p>
                            <pre class="code-block"><code>void setup() {
  Serial.begin(9600);           // USB seri port — bilgisayarda Serial Monitor ile debug
  gpsSerial.begin(9600);        // GPS modülü 9600 baud kullanır

  pinMode(GEIGER_PIN, INPUT);   // D2 = giriş
  attachInterrupt(digitalPinToInterrupt(GEIGER_PIN), geigerISR, RISING);  // Her HIGH’da geigerISR çağrılır

  oledInit();                   // I2C ve OLED komutları ile ekranı aç
  oledClear();                  // Ekranı temizle
  oledPrint(0, 0, "RADMAP");
  oledPrint(0, 2, "Baslatiliyor...");   // Kullanıcıya mesaj

  for (uint8_t i = 0; i &lt; 5; i++) { sdOk = SD.begin(SD_CS_PIN); if (sdOk) break; delay(300); }
  if (!sdOk) {   // SD kartı D10 (CS) ile başlat
    oledPrint(0, 4, "SD HATA!");       // Başarısızsa uyarı
    delay(2000);
  }

  memset(counts, 0, sizeof(counts));  // counts[] dizisini 0’la
  lastLogTime = millis();             // İlk 1 sn sayacını başlat
}</code></pre>
                            <p><strong>Blok özeti:</strong> Seri (USB + GPS) → Geiger pini + kesme → OLED başlat + başlık → SD başlat (yoksa hata yaz) → sayacı sıfırla, zamanı kaydet.</p>
                        </div>
                    </details>

                    <!-- ========== 7. loop() BLOK BLOK ========== -->
                    <details class="guide-accordion" open>
                        <summary>7. loop() — Ana döngü (blok blok)</summary>
                        <div class="guide-body">
                            <p><strong>loop()</strong> sürekli tekrarlanır. İki ana iş var: (1) GPS’ten gelen her byte’ı işlemek, (2) her 1 saniyede bir ölçüm yapıp SD’ye yazmak ve ekranı güncellemek.</p>
                            <p class="code-caption">Blok 1: GPS verisini işle (+ gpsByteCount)</p>
                            <pre class="code-block"><code>while (gpsSerial.available()) {
  gps.encode(gpsSerial.read());
  gpsByteCount++;   // Saniyede kaç byte geldiği — Serial’da GPS_byt olarak görünür
}</code></pre>
                            <p>Bu blok her loop’ta çalışır; gelen byte kalmayana kadar okur. <code>GPS_byt: 0</code> ise GPS TX→D3 bağlantısını kontrol et.</p>
                            <p class="code-caption">Blok 2: 1 saniye doldu mu kontrol et</p>
                            <pre class="code-block"><code>if (millis() - lastLogTime &gt;= 1000) {
  lastLogTime = millis();   // Bir sonraki 1 sn için zamanı kaydet
  uptimeSeconds++;          // Toplam çalışma saniyesini artır</code></pre>
                            <p class="code-caption">Blok 3: Kesmeden pulse sayısını al</p>
                            <pre class="code-block"><code>  noInterrupts();
  uint8_t currentSecCounts = pulseCount;
  pulseCount = 0;
  interrupts();</code></pre>
                            <p class="code-caption">Blok 4: Dairesel tampon + CPM + µSv/h</p>
                            <pre class="code-block"><code>  totalCountsInWindow -= counts[bufferIndex];
  counts[bufferIndex] = currentSecCounts;
  totalCountsInWindow += currentSecCounts;
  bufferIndex = (bufferIndex + 1) % 60;

  uint32_t cpm = 0;
  if (uptimeSeconds &lt; 60) {
    if (uptimeSeconds &gt; 0) cpm = (totalCountsInWindow * 60) / uptimeSeconds;
  } else {
    cpm = totalCountsInWindow;
  }
  float usvh = cpm * 0.00812;</code></pre>
                            <p class="code-caption">Blok 5: GPS değerlerini al (Enlem, Boylam, Uydu)</p>
                            <pre class="code-block"><code>  float lat = gps.location.isValid() ? (float)gps.location.lat() : 0.0f;
  float lng = gps.location.isValid() ? (float)gps.location.lng() : 0.0f;
  uint8_t uyduSayisi = gps.satellites.isValid() ? (uint8_t)gps.satellites.value() : 0;</code></pre>
                            <p class="code-caption">Blok 6: LOG.csv’ye yaz, Serial’da Enlem/Boylam/Uydu ve GPS_byt göster</p>
                            <pre class="code-block"><code>  if (sdOk) sdWritten = writeToSD(cpm, usvh, lat, lng, uyduSayisi);

  Serial.print(F("CPM:")); Serial.print(cpm);
  Serial.print(F(" uSv/h:")); Serial.print(usvh, 3);
  Serial.print(F(" Enlem:")); Serial.print(lat, 6);
  Serial.print(F(" Boylam:")); Serial.print(lng, 6);
  Serial.print(F(" Uydu:")); Serial.print(uyduSayisi);
  Serial.print(F(" | GPS_byt:")); Serial.print(gpsByteCount);
  Serial.print(F(" | SD:")); Serial.println(sdWritten ? F("OK") : F("HATA"));
  gpsByteCount = 0;</code></pre>
                            <p class="code-caption">Blok 7: OLED’i güncelle (RADMAP, CPM, uSv/h, GPS durumu, SDOK/SD--)</p>
                            <pre class="code-block"><code>  oledClear();
  oledPrint(0, 0, "RADMAP");
  oledPrint(0, 2, "CPM: ");
  oledPrintNum(36, 2, cpm);
  oledPrint(0, 4, "uSv/h: ");
  oledPrintFloat(42, 4, usvh, 3);
  oledPrint(0, 6, gps.location.isValid() ? "GPS OK" : "GPS...");
  if (!sdOk) oledPrint(70, 6, "SD--");
  else if (sdWritten) oledPrint(70, 6, "SDOK");
  else oledPrint(70, 6, "SD!!");
}
// if (millis() - lastLogTime >= 1000) sonu</code></pre>
                            <p>Özet: Her saniye sayacı oku → CPM/µSv/h hesapla → Enlem, Boylam, Uydu al → LOG.csv’ye yaz → Serial ve OLED güncelle; <code>gpsByteCount</code> sıfırlanır.</p>
                        </div>
                    </details>

                    <!-- ========== 8. TAM KOD ÖZET ========== -->
                    <details class="guide-accordion">
                        <summary>8. Tam program yapısı (dosya sırası)</summary>
                        <div class="guide-body">
                            <p>Öğrenciler yukarıdaki bölümleri okuduktan sonra aşağıdaki sırayı referans alabilir. Tam .ino dosyasında sıra kabaca şöyle:</p>
                            <ol>
                                <li>#include ve #define</li>
                                <li>OLED sabitleri (OLED_ADDR, OLED_W, OLED_H, OLED_PAGES, WIRE_CHUNK)</li>
                                <li>oledCmd → oledInit → oledClearPage → oledClear</li>
                                <li>font5x7 dizisi (PROGMEM)</li>
                                <li>charToIdx → oledDrawChar → oledPrint → oledPrintNum → oledPrintFloat</li>
                                <li>GEIGER/GPS/SD pinleri, counts[], bufferIndex, totalCountsInWindow, uptimeSeconds, lastLogTime, pulseCount, lastInterruptTime</li>
                                <li>geigerISR()</li>
                                <li>TinyGPSPlus gps; SoftwareSerial gpsSerial(...)</li>
                                <li>formatTarihSaat(), writeToSD(...) → LOG.csv</li>
                                <li>setup()</li>
                                <li>loop()</li>
                            </ol>
                            <p>Tam kod proje klasöründeki <strong>RadMap_Tam.ino</strong> dosyasındadır; bu rehberde her fonksiyonun ve döngünün ne işe yaradığı özetlenmiştir.</p>
                        </div>
                    </details>

                    <div style="margin-top: 1.25rem;">
                        <a class="btn" href="rehberler.html">← Tüm rehberler</a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>RadMap | SANKODE Intelligence &copy; 2025 | Codeavour 7.0 Track 1 | Temiz Gezegen, Sağlıklı İnsanlar</p>
    </footer>
</body>
</html>
